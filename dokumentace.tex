%% LyX 2.2.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[12pt,czech,pdftex,titlepage]{report}
\usepackage{lmodern}
\usepackage{lmodern}
\renewcommand{\familydefault}{\ttdefault}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[a4paper]{geometry}
\geometry{verbose,tmargin=2cm,lmargin=2cm,rmargin=3cm}
\usepackage{color}
\usepackage{array}
\usepackage{float}
\usepackage{graphicx}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\newcommand{\noun}[1]{\textsc{#1}}
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.


\usepackage[czech]{babel}
\usepackage{textcomp}
\usepackage{amsfonts}
\usepackage{titlesec}


\titleformat{\chapter}
  {\normalfont\LARGE\bfseries}{\thechapter}{1em}{}
\titlespacing*{\chapter}{0pt}{0ex plus 1ex minus .2ex}{2.0ex plus .2ex}

\makeatother

\usepackage{babel}
\usepackage{listings}
\renewcommand{\lstlistingname}{\inputencoding{latin2}V˝pis}

\begin{document}
\begin{titlepage} \vspace*{2cm}
 {\centering\includegraphics{pripravena-dokumentace-v-latexu/logo}\par }
\centering \vspace*{2cm}
 {\Large Semestr√°ln√≠ pr√°ce z KIV/PC\par } \vspace{1.5cm}
 {\Huge\bfseries Vyhled√°v√°n√≠ cest v grafu 

technikou DFS\par } \vspace{2cm}
\par {\Large Radek Juppa}\medskip{}

\par {\Large {\small{}Student: A16B0039K} }

\vfill{}
\par {\Large 20.\,1.\,2018} \end{titlepage}

\thispagestyle{empty} \clearpage{}

\setcounter{page}{1}

\begin{table}
\begin{tabular}{>{\centering}p{4cm}>{\centering}p{10cm}>{\centering}p{4cm}}
 & %
\noindent\begin{minipage}[t]{1\columnwidth}%

\paragraph*{Obsah}
\begin{enumerate}
\item Zad√°n√≠ 
\begin{enumerate}
\item Specifikace v√Ωstupu programu 
\item ≈òazen√≠ v√Ωstupu 
\end{enumerate}
\item Anal√Ωza √∫lohy 
\begin{enumerate}
\item Anal√Ωza grafu 
\item Metoda proch√°zen√≠ grafu 
\item Algoritmus
\end{enumerate}
\item Popis implementace 
\item U≈æivatelsk√° p≈ô√≠ruƒçka 
\item Z√°vƒõr
\end{enumerate}
%
\end{minipage} & \tabularnewline
\end{tabular}

\end{table}

\pagebreak{}

\chapter*{1. Zad√°n√≠}

\noindent Naprogramujte v ANSI C p≈ôenositelnou konzolovou aplikaci,
kter√° bude proch√°zet graf technikou DFS (Depth-First Search). Vstupem
aplikace bude soubor s popisem grafu. V√Ωstupem je pak odpov√≠daj√≠c√≠
v√Ωƒçet v≈°ech cest mezi po≈æadovan√Ωmi uzly grafu. 
\begin{verbatim*}
Program se bude spou≈°tƒõt p≈ô√≠kazem dfs.exe <soubor-grafu> <id1> <id2> <maxD>
\end{verbatim*}
\begin{itemize}
\item Symbol <soubor-grafu> zastupuje parametr ‚Äì n√°zev vstupn√≠ho souboru
se strukturou grafu. 
\item N√°sleduj√≠ identifik√°tory (d√°le jen id) dvou uzl≈Ø v grafu <id1> a <id2>,
mezi kter√Ωmi bude spou≈°tƒõn proces hled√°n√≠ cest. 
\item <maxD>je parametr popisuj√≠c√≠ maxim√°ln√≠ d√©lku cest, kter√© maj√≠ b√Ωt
nalezeny. 
\item V√°mi vyvinut√Ω program tedy bude vykon√°vat n√°sleduj√≠c√≠ ƒçinnosti. 
\begin{enumerate}
\item P≈ôi spu≈°tƒõn√≠ bez pot≈ôebn√Ωch parametru vyp√≠≈°e n√°povƒõdu pro jeho spr√°vn√©
spu≈°tƒõn√≠ a ukonƒç√≠ se.
\item P≈ôi spu≈°tƒõn√≠ s parametry naƒçte zadan√Ω vstupn√≠ soubor do vhodn√© struktury
reprezentuj√≠c√≠ graf a mezi zadan√Ωmi uzly najde v≈°echny cesty, jejich≈æ
d√©lka nep≈ôekroƒç√≠ konstantu nastavenou posledn√≠m parametrem.
\end{enumerate}
\end{itemize}

\subsection*{1.a) Specifikace v√Ωstupu programu}

Program bude na standardn√≠ v√Ωstup vypisovat jednotliv√© cesty. V≈ædy
na jeden ≈ô√°dek pr√°vƒõ jednu cestu. Cesty budou pops√°ny posloupnost√≠
id jednotliv√Ωch uzl≈Ø oddƒõlen√Ωch pomlƒçkou (tj. znakem minus). N√°sledovat
bude st≈ôedn√≠k a popisky jednotliv√Ωch hran v grafu oddƒõlen√© ƒç√°rkou
(viz P≈ô√≠loha 1). Za posledn√≠m st≈ôedn√≠kem bude uvedena hodnota sekund√°rn√≠
metriky ‚Äì relevance cesty, podle kter√© budou cesty se≈ôazeny (viz ≈òazen√≠
v√Ωstupu).

\noindent \vspace{0.5cm}
Nap≈ô√≠klad tedy pro hled√°n√≠ cest mezi uzly A a B: 

\textit{\small{}A-B;h1;m1}{\small \par}

\textit{\small{}A-F-B;h2,h3;m2,3}{\small \par}

\textit{\small{}A-W-B;h4,h5;m4,5}{\small \par}

\textit{\small{}A-F-O-B;h2,h6,h7;m2,6,7}\medskip{}

\noindent Kde A,B,F,W,F,... jsou popisky uzl≈Ø grafu, hn jsou ohodnocen√≠
hran a mc1,c2...cn je hodnota metrika relevance nalezen√© cesty.\pagebreak{}

\subsection*{1.b) ≈òazen√≠ v√Ωstupu}

Cesty budou na standardn√≠m v√Ωstupu se≈ôazeny prim√°rnƒõ podle jejich
d√©lky. Pokud bude nalezeno v√≠ce cest stejn√© d√©lky, budou se≈ôazeny
podle jejich relevance n√°sleduj√≠c√≠m zp≈Øsobem. Popisky v grafu nesou
informaci o kalend√°≈ôn√≠m datu ve form√°tu YYYY-MM-DD. Ka≈æd√° cesta bude
tedy ohodnocena cel√Ωm ƒç√≠slem, kter√© bude odpov√≠dat rozd√≠lu v poƒçtu
dn√≠ mezi nejstar≈°√≠m a nejnovƒõj≈°√≠m datem, n√°slednƒõ budou podle tohoto
ƒç√≠sla cesty se shodnou d√©lkou se≈ôazeny vzestupnƒõ.

\pagebreak{}

\chapter*{2. Anal√Ωza √∫lohy}

\section*{2.a) Anal√Ωza grafu}

Nejprve se pojƒème pod√≠vat, co to je za graf. Na prvn√≠ pohled je vidƒõt,
≈æe je to velk√Ω graf s nƒõkolika tis√≠ci uzl≈Ø. Vizualizace cel√©ho grafu
by byla dost obt√≠≈æn√°. Proto si vyberu jen nƒõjak√Ω podgraf. Pou≈æil jsem
k tomu \emph{Python} a knihovnu \emph{networkx}. Vybral jsem si prvn√≠ch
16 r≈Øzn√Ωch vrchol≈Ø a vzal jsem v √∫vahu jen 8 soused≈Ø ka≈æd√©ho vrcholu. Vizualizaci
tohoto podgrafu jsem provedl pomoc√≠ knihovny \emph{graphviz}.

\begin{figure}[H]
\includegraphics[scale=0.4]{fig0}\caption{podgraf}

\end{figure}

\noindent Na obr√°zku vid√≠me, ≈æe se jedn√° o orientovan√Ω graf s kru≈ænicemi. Z
tƒõchto informac√≠ usuzuji, ≈æe obecn√Ω poƒçet cest mezi 2 vrchly grafu,
vzhledem ke kru≈ænic√≠m, bude nekoneƒçnƒõ mnoho. Proto d√°v√° smysl omezen√≠
maxim√°ln√≠ d√©lky cesty, kter√© je uvedeno v zad√°n√≠. 

\pagebreak{}

\section*{2.b) Metoda proch√°zen√≠ grafu}

Pro prohled√°v√°n√≠ grafu existuj√≠ 2 z√°kladn√≠ metody \emph{Breadth First
Search} - \emph{BFS} a \emph{Deep First Search} - \emph{DFS}. My m√°me
pou≈æ√≠t techniku DFS, co≈æ je prohled√°v√°n√≠ do hloubky. Konkr√©tnƒõ to
znamen√°, ≈æe p≈ôi prohled√°v√°n√≠ postupujeme po listech do hloubky. Tedy
na obecn√©m grafu, kter√Ω je zobrazen na obr√°zku 2 to bude sekvence
vrchol≈Ø {[}1-2-5-7-8-3..{]} Kde≈æto BFS proch√°z√≠ nejd≈ô√≠ve nejbli≈æ≈°√≠
uzly. BFS sekvence by vypadala n√°sledovnƒõ: {[}1-2-3-4-6-5-7‚Ä¶{]}

\begin{figure}[H]

\includegraphics[scale=0.8]{fig01}\caption{DFS}

\end{figure}

\medskip{}
\pagebreak{}

\section*{2.c) Algoritmus}

Vra≈•me se teƒè opƒõt k na≈°emu grafu. Vezmu si je≈°tƒõ men≈°√≠ podgraf (Vyberu
podgraf s vrcholy: 1, 2, 4, 5, 6, 7, 8) a zkus√≠m naj√≠t v≈°echny cesty
mezi vrcholy 1 a 5 s maxim√°ln√≠ d√©lkou cesty 2. viz obr√°zek 3

\begin{figure}[H]

\includegraphics[scale=0.15]{graphviz2}\caption{v≈°echny cesty z 1 do 5 (maxD=2)}

\end{figure}

Zde je tabulka v≈°ech cest o maxim√°ln√≠ d√©lce 2 z vrcholu 1:

\begin{table}[H]

\begin{tabular}{|c|c|c|c|}
\hline 
1-2-4 NE  & 1-3-5 \textbf{\textcolor{green}{\noun{ANO}}}  & 1-6-2 NE  & 1-7-5 \textbf{\textcolor{green}{ANO}} \tabularnewline
\hline 
1-2-5 \textbf{\textcolor{green}{ANO}}  & 1-4-2 NE  & 1-6-4 NE  & 1-7-8 NE \tabularnewline
\hline 
1-2-6 NE  & 1-4-6 NE  & 1-7-2 NE  & \tabularnewline
\hline 
1-2-8 NE  & 1-4-7 NE  & 1-7-3 NE  & \tabularnewline
\hline 
1-3-4 NE  & 1-4-8 NE  & 1-7-4 NE  & \tabularnewline
\hline 
\end{tabular}\caption{cesty z vrcholu 1 do vrcholu 5 (maxD = 2)}

\end{table}

Je vidƒõt, ≈æe jen 3 cesty vedou do vrcholu 5. Budu tedy pou≈æ√≠vat techniku
\emph{DFS}. Vrcholy, jimi≈æ jsem pro≈°el, si budu ukl√°dat do z√°sobn√≠ku. Tak
budu postupovat dokud budu m√≠t kam vstupovat nebo dokud nevstoup√≠m
do c√≠lov√©ho vrcholu nebo nedos√°hnu maxim√°ln√≠ d√©lky cesty. V opaƒçn√©m
p≈ô√≠padƒõ se vr√°t√≠m do vrcholu ze kter√©h√© jsem p≈ôi≈°el. Pokud vstoup√≠m
do c√≠lov√©ho vrcholu cestu si ulo≈æ√≠m jako jedno z ≈ôe≈°en√≠. Na konci
pak v≈°echny nalezen√© cesty se≈ôad√≠m a vytisknu.

\chapter*{3. Popis implementace }

Aby bylo mo≈æno graf proch√°zet, je t≈ôeba ho nejprve ulo≈æit do nƒõjak√©
vhodn√© struktury. Samotn√Ω graf tvo≈ô√≠ mno≈æina vrchol≈Ø a hran. Vrchol
je tvo≈ôen jednou integer hodnotou a hrana spojuje 2 vrcholy a je ohodnocena
≈ôetƒõzcem znak≈Ø. Vrcholy i hrany ulo≈æ√≠m do spojov√©ho seznamu.

\medskip{}

\noindent Struktura pro vrchol \emph{VERTEX} bude vypadat n√°sledovnƒõ: 

\inputencoding{latin2}\begin{lstlisting}[basicstyle={\scriptsize\ttfamily},tabsize=4]
typedef struct vertex{       // VERTEX (as linked list)     
    int id;                  // id of the vertex     
    EDGE *first_edge;        // reference to the first edge (as linked list)     
    struct vertex *next;     // next item 
} VERTEX;
\end{lstlisting}
\inputencoding{utf8}
\medskip{}

\noindent Hrany ulo≈æ√≠m do struktury \emph{EDGE}: 

\inputencoding{latin2}\begin{lstlisting}[basicstyle={\scriptsize}]
typedef struct edge{        // EDGE (as linked list)     
    int id;                 // id of vertex creating an edge with its parent     
    char *data;             // data(label) assign to the edge     
    struct edge *next;      // next item 
} EDGE;
\end{lstlisting}
\inputencoding{utf8}
\medskip{}
Tak, jak budu grafem proch√°zet, budu si jednotliv√© vrcholy ukl√°dat
do z√°sovn√≠ku \emph{STACK}:

\inputencoding{latin2}\begin{lstlisting}[basicstyle={\scriptsize}]
typedef struct stack_item{     
    int id;                  // id of a vertex
    char *data;              // label of an edge
    struct stack_item *next; // reference to next item in linked list
} STACK_ITEM; 

typedef struct stack{     
    STACK_ITEM *top;         // the first vertex
    int count;               // count of items in the stack
} STACK;
\end{lstlisting}
\inputencoding{utf8}
\medskip{}
Z√°sobn√≠k je implementov√°n ve sv√©m vlastn√≠m modulu nazvan√©m \emph{stack.c.} Bude
ukl√°dat aktu√°ln√≠ cestu a bude k tomu pou≈æ√≠vat dvƒõ typick√© metody:

\inputencoding{latin2}\begin{lstlisting}[basicstyle={\scriptsize}]
void stack_push(STACK *stack, int id, char *data); 
int stack_pop(STACK *stack); 
\end{lstlisting}
\inputencoding{utf8}
\medskip{}
Pokud aktu√°ln√≠ cesta dos√°hne c√≠lov√©ho vrcholu, bude ulo≈æena do se≈ôazen√©ho
spojov√©ho seznamu √∫spƒõ≈°n√Ωch cest typu \emph{RESULT}. Tuto strukturu
definuji n√°sledovnƒõ:

\inputencoding{latin2}\begin{lstlisting}[basicstyle={\scriptsize}]
typedef struct result{       // RESULT (as sorted linked list)
    int *vertexes;           // array of vertex ids
    struct tm *labels;       // array of labels (datetime struct)
    int length;              // length of path
    int score;               // number of days between the first and the last date
    struct result *next;     // next item
} RESULT;
\end{lstlisting}
\inputencoding{utf8}
\medskip{}
\pagebreak{}Pro ulo≈æen√≠ celkov√© struktury grafu vƒçetnƒõ aktu√°ln√≠ cesty
a v√Ωsledk≈Ø bude slou≈æit struktura \emph{GRAPH}:

\inputencoding{latin2}\begin{lstlisting}[basicstyle={\scriptsize}]
typedef struct graph{     
    VERTEX *first_vertex;     
    STACK *current_path;     
    int count;     
    int start_vertex_id;     
    int target_vertex_id;     
    int limit;     
    RESULT *result; 
} GRAPH;
\end{lstlisting}
\inputencoding{utf8}
\medskip{}
Graf je implementov√°n ve sv√©m vlastn√≠m modulu nazvan√©m \emph{graph.c}
Nejd≈Øle≈æitej≈°√≠ metodou, kter√° proch√°z√≠ graf a hled√° cesty je metoda: 

\inputencoding{latin2}\begin{lstlisting}[basicstyle={\scriptsize}]
void graph_dfs(GRAPH *g)
\end{lstlisting}
\inputencoding{utf8}
\chapter*{4. U≈æivatelsk√° p≈ô√≠ruƒçka}

Program je dod√°n v podobƒõ zdrojov√©ho k√≥du a proto je nutno jej nejprve
p≈ôelo≈æit. P≈ôelo≈æen√≠ programu je shodn√© pro v≈°echny hlavn√≠ platformy: Windows,
Linux, MacOS 

\medskip{}

\noindent P≈ôedpokladem √∫spƒõ≈°n√©ho p≈ôelo≈æen√≠ je p≈ô√≠tomnost p≈ôekladaƒçe
jazyka C. V ko≈ôenov√©m adres√°≈ôi je soubor \emph{makefile}, kter√Ω zaji≈°tuje
p≈ôeklad. 

\noindent \medskip{}
P≈ôeklad se provede p≈ô√≠kazem: \emph{make}

\inputencoding{latin2}\begin{lstlisting}[basicstyle={\scriptsize}]
$ make  
\end{lstlisting}
\inputencoding{utf8}
P≈ô√≠kaz make vyp√≠≈°e zpr√°vu o spu≈°tƒõn√≠ p≈ôekladaƒçe a vytvo≈ô√≠ soubor \emph{dfs.exe}
V p≈ô√≠padƒõ probl√©mu se nejprve p≈ôesvƒõƒçte, ≈æe compiler jazyka C funguje. Napi≈°te
p≈ô√≠kaz pro vyps√°n√≠ verze p≈ôekladaƒçe: \emph{gcc ‚Äîversion} Pokud nezobrazi
verzi, pak pravdƒõpodobnƒõ nen√≠ nainstalov√°n nebo k nƒõmu chyb√≠ cesta
v promƒõnn√© \emph{\noun{PATH}}. Pokud se V√°m program poda≈ôilo p≈ôelo≈æit
a vytvo≈ôil se soubor \emph{dfs.exe}, pak jej m≈Ø≈æete spustit n√°sleduj√≠c√≠m
zp≈Øsobem:

\inputencoding{latin2}\begin{lstlisting}[basicstyle={\scriptsize}]
$ ./dfs.exe <cesta> <id_start> <id_target> [maxDistance=5]
\end{lstlisting}
\inputencoding{utf8}
\medskip{}

\noindent Pokud nezad√°te povinn√© vstupn√≠ parametry, program vyp√≠≈°e
n√°povƒõdu:

\inputencoding{latin2}\begin{lstlisting}[basicstyle={\scriptsize}]
$ ./dfs.exe  
***** Search for Path using DFS ****** 
* Seminar work of 'Programming in C' * 
*  Copyright (c) Radek Juppa, 2017   * 
**************************************  
Usage:  dfs.exe <filename> <id1> <id2> [maxD]  
Example:  
  dfs.exe graph.csv 1 2 3
\end{lstlisting}
\inputencoding{utf8}
\medskip{}

\noindent P≈ô√≠klad spu≈°tƒõn√≠ programu:

\inputencoding{latin2}\begin{lstlisting}[basicstyle={\scriptsize}]
$ ./dfs.exe sw2017-02-data.csv 1 29 3  

1-6-29;2007-06-14,2007-06-11;3 
1-25-29;2007-02-04,2007-02-01;3 
1-2-29;2007-02-16,2007-04-30;73 
1-3-29;2007-10-26,2008-01-18;84 
1-882-29;2007-11-02,2007-08-03;91 
1-4698-29;2007-05-29,2007-10-04;128 
1-21935-29;2007-01-31,2007-06-26;146  
1-780-29;2007-10-29,2007-05-30;152 
1-67-29;2007-08-07,2008-01-08;154 
1-7-29;2007-08-14,2007-02-23;172 
1-67-29;2007-05-08,2008-01-08;245 
1-25-29;2007-10-31,2007-02-01;272 
1-2-29;2008-02-15,2007-04-30;291 
1-3306-29;2008-01-17,2007-02-27;324 
1-777-29;2008-02-14,2007-03-13;338 
1-16-29;2008-03-05,2007-03-09;362 
1-2917-29;2008-09-09,2007-08-05;401 
1-1230-29;2007-01-15,2008-03-19;429
\end{lstlisting}
\inputencoding{utf8}
\medskip{}

\medskip{}
Program naƒçetl soubor \emph{sw2017-02-data.csv} z aktu√°ln√≠ho adres√°≈ôe
a vyhledal v≈°echny cesty mezi vrchly 1 a 29, kter√© jsou dlouh√© maxim√°lnƒõ
3 hrany. Vid√≠me, ≈æe program na≈°el 18 cest a vypsal je se≈ôazen√© podle
jejich d√©lky a hodnoty hran.

\chapter*{5. Z√°vƒõr}

Tato √∫loha mi dala p≈ô√≠le≈æitost si vyzkou≈°et dynamick√© vytv√°≈ôen√≠ datov√°ch
strukt≈Ør jako je spojov√Ω seznam, z√°sobn√≠k ƒçi graf pomoc√≠ jazyka C. D√°le
jsem si vyzkou≈°el n√°stroj pro kontrolu uvol≈àov√°n√≠ pamƒõti programem
valgrind. A nauƒçil jsem se napsat jednoduch√Ω makefile pro r≈Øzn√© platformy. Program
jsem testoval v prost≈ôed√≠ Linuxu s p≈ôekladaƒçem gcc a v prost≈ôed√≠ Windows
s p≈ôekladaƒçem MinGW. To pova≈æuji za solidn√≠ √∫vod do programov√°n√≠ v
jazyce C. Dokumentaci jsem vytvo≈ôil v programu LYX.
\end{document}
